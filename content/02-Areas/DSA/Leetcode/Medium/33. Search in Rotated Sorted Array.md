---
{"aliases":null,"created":"2025-01-17T09:09:04.023+05:30","modified":null,"completed":false,"redo":false,"Perfect":false,"publish":true,"Description":null,"leetcode-index":33,"link":"https://leetcode.com/problems/search-in-rotated-sorted-array","difficulty":"Medium","tags":["leetcode/array","leetcode/binary-search","programming/practice"],"date created":"2025-01-16T20:23","date modified":"2025-01-17T09:09","PassFrontmatter":true,"updated":"2025-01-17T09:09:04.023+05:30"}
---


> [!learnings]
## Problem Statement

There is an integer array `nums` sorted in ascending order (with distinct values).

Prior to being passed to your function, `nums` is possibly rotated at an unknown pivot index `k` (`1 <= k < nums.length`) such that the resulting array is `[nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]` (0-indexed). For example, `[0,1,2,4,5,6,7]` might be rotated at pivot index `3` and become `[4,5,6,7,0,1,2]`.

Given the array `nums` after the possible rotation and an integer `target`, return *the index of *`target`* if it is in *`nums`*, or *`-1`* if it is not in *`nums`.

You must write an algorithm with `O(log n)` runtime complexity.

 

>[!Example]+ Example 1
>**Input**: `nums = [4,5,6,7,0,1,2], target = 0`
>**Output**: `4
`

>[!Example]+ Example 2
>**Input**: `nums = [4,5,6,7,0,1,2], target = 3`
>**Output**: `-1
`

>[!Example]+ Example 3
>**Input**: `nums = [1], target = 0`
>**Output**: `-1
`

>[!warning]+ Constraints
>- `1 <= nums.length <= 5000`
>
>- `-10^4 <= nums[i] <= 10^4`
>
>- All values of `nums` are unique.
>
>- `nums` is an ascending array that is possibly rotated.
>
>- `-10^4 <= target <= 10^4`

## Relevant Concepts

### External Resources

## Scratchpad
```



```
## Approaches
### Approach 1

#### Complexity Analysis
##### Time
##### Space
#### Solution
```Java
# Solution
```
